
def w2t_bool(c, w, name):
    r = c.representation
    tf = c.punctuation.true_false
    if w:
        r.write(tf[0])
    else:
        r.write(tf[1])

def w2t_int(c, w, name):
    r = c.representation
    value = '%d' % (w,)
    r.write(value)

def w2t_float(c, w, name):
    r = c.representation
    value = '%f' % (w,)
    value = value.rstrip('0')
    r.write(value)

def w2t_str(c, w, name):
    r = c.representation
    r.write(w)

def list_of_pairs(w):
    for t in w:
        if not isinstance(t, list) or len(t) != 2:
            return False
    return True

def w2t_list(c, w, name):
    if list_of_pairs(w):
        w2t_kv(c, w, name)
        return
    r = c.representation
    le = c.punctuation.list_ends
    ls = c.punctuation.list_separator
    n = len(w)
    if le[0]:
        r.write(le[0])
    for i in range(n):
        word_to_text(c, w[i], None)
        if (i + 1) < n and ls:
            r.write(ls)
    if le[1]:
        r.write(le[1])

def w2t_dict(c, w, name):
    r = c.representation
    de = c.punctuation.message_ends
    ds = c.punctuation.message_separator
    dc = c.punctuation.message_colon
    n = len(w)
    if de[0]:
        r.write(de[0])
    for k, v in w.items():
        r.write(k)
        if dc:
            r.write(dc)
        word_to_text(c, v, None)
        if (n - 1) > 0 and ds:
            r.write(ds)
        n -= 1
    if de[1]:
        r.write(de[1])

def w2t_kv(c, w, name):
    r = c.representation
    de = c.punctuation.message_ends
    ds = c.punctuation.message_separator
    dc = c.punctuation.message_colon
    n = len(w)
    if de[0]:
        r.write(de[0])
    for kv in w:
        word_to_text(c, kv[0], None)
        if dc:
            r.write(dc)
        word_to_text(c, kv[1], None)
        if (n - 1) > 0 and ds:
            r.write(ds)
        n -= 1
    if de[1]:
        r.write(de[1])

def w2t_none(c, w, name):
    r = c.representation
    n = c.punctuation.no_value
    r.write(n)

w2t = {
    bool: w2t_bool,
    int: w2t_int,
    float: w2t_float,
    str: w2t_str,
    list: w2t_list,
    dict: w2t_dict,
    type(None): w2t_none,
}

# Transform the generic data to rather inconvenient XML form.
def word_to_text(c, w, name):
    try:
        a = getattr(w, '__class__')
    except AttributeError:
        raise TypeError('word is unusable')

    try:
        f = w2t[a]
    except KeyError:
        raise TypeError('no transformation for word %s' % (a.__name__,))

    # Apply the transform function
    return f(c, w, name)

# Generate args text representation of a
# generic word.
def word_to_args(c, w):
    """Generate the args representation of a generic word.

    :param c: an active codec
    :type c: a Codec-based object
    :param w: a generic word
    :rtype: the args text.
    """
    c.representation = io.StringIO()
    word_to_text(c, w, None)

    return c.representation.getvalue()

# Decoding - from parsing of JSON to transformation
# into app data items.

def args_to_word(c, x):
    """Blah.

    Rhubarb.
    """
    raise ar.CodecError('cannot decode args')

#
#

