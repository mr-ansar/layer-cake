BRIEF OVERVIEW OF MAINTENANCE MANAGEMENT AND SOFTWARE UPDATING

there are n client-processes (each running one client object) and a single server (running n
server objects).

the client-processes will cause the execution of the following according to saved information,
as directed by the server and subject to prevailing constraints;
1. there are n maintenance tasks (regular)
2. there are n software-update tasks (one-offs)
3. there is an update of the update software task (one-off) 
4. there are commands to be executed immediately usually as resolution of issues
5. maintenance, update and command tasks can be managed according to site tags

the prevailing constraints include;
1. business hours (i.e. dont clobber buddy users)
2. webman, i.e. availability of /admin
3. CPU load, i.e. prevent overloading or inefficient contention
4. RAM usage, i.e. prevent out-of-memory or contention
5. Disk bandwidth, space, i.e. prevent contention or out-of-space.
6. Assigned networking timeslot, i.e. use this network at this time offset.
7. Network service, e.g. package server to be used at this time offset.
8. Update of the update service requires that there is nothing else happening, i.e. everything
else completed.

The modelling of network interfaces and network services probably the hardest. Its possible that
it could be simplified to just use of a network service as this is implicitly an interface.

The convenient example for discussion is the package repo that will be accessed by all software-
updates. It's a global resource (on the 'net) and could be load-balanced at that scope, i.e. every
client-process known gets a slot in the 24h GMT working day. However this doesnt consider the fact that
each site has its own business hours and each site is located within a certain timezone. It also
doesnt pay heed to issue of the local LAN, i.e. it could assign slots such that the local network
becomes the point of contention.

It has been suggested that the issue of load-balancing the package repo doesnt exist. it would
be solved by something like a cdn. which sort of says that it *is* a loading issue its just that
it can be solved outside the scope of client process scheduling. outside solutions always welcome but
the fact that this could still result in heavily loaded LANs means it doesnt feel like a total
solution.

A fully generic scheduling algorithm is deferred. Not only would it be a complex thing to
implement - hold a model, evaluate tasks to run, manage active tasks, accept changes - it
would be very difficult to test with any great coverage.

The approach is simplified to the following;
* there is a collection of housekeeping tasks that are to be completed after-hours.
* there is a collection of software update tasks that are to be completed after the daily housekeeping.
* there is the update of software update task that will be completed after the general software updates.
* there is a collection of shared-resource tasks that need to run within assigned time-slots.
* each shared-resource task is assigned a "sharing token" and a base time
* the sharing token and base time are used to evaluate the daily execution time.
* there is a sharing profile stored by each client, that contains all the sharing tokens and their base times.
* execution of every shared-resource task is preceded by a reserved "buffer zone" where new tasks cannot be started.
* the clients always have enough info in the sharing profile to calculate a useful schedule for the day
* there is a dynamic collection of command tasks that will be started at the next opportunity.

* calculate the shared-resource timeslots
* add the buffer zones
* compose the list of housekeeping tasks.
* compose the list of software update tasks.
* optionally add the update of software update task.
* the list of housekeeping+update tasks are started at start of after-hours + some grace period
* tasks from the housekeeping+update list are executed in a sequence.
* the housekeeping+update sequence is placed on hold for any shared-resource task and its buffer zone.
* fresh commands are accepted at any time and will be executed prior to the next housekeeping task
* sharing tokens and base times can be updated at any time
* the collection of housekeeping tasks can be updated at any time
* for each day there is a "to do" list, active tasks and a completed/failed list.
* updates (sharing tokens, base times or housekeeping) will cause a re-evaluation of the "to do" list.
* each re-evaluation will have those items in the completed/failed list trimmed.
* a non-empty failed list will be notified to the admin.
* there may be optimizations in the execution of housekeeping, i.e. multiple concurrent tasks.
* there may be optimizations in the concurrent execution of housekeeping and shared-resource tasks, i.e. where there is no contention.
