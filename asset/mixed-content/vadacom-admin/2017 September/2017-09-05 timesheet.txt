11-12
started with nics feedback regarding logging
tagged all the log sites in the messaging layer
evaluating where logging impl should live in the code
how it will integrate with webman loggers
and how to get async details into the webman format
12-1
completed all the log sites - quite distributed
and at different levels of the software, urgh.
e.g. send is easy in point class, destroy is tricky
cos it involves point destruction and thread termination.
created summary table.
considering possible implementations
3-7
considered different impls;
* manual marking of Points and Messages with is_logging
* dicts of Point and Message blacklists
* automated marking of Ps and Ms by a func that is called before root_object
decided on the latter. need something like "prepare points and messages for logging".
that accepts different config tables and uses them to manipulate the Ps and Ms
such that runtime logging can be as optimal as possible. can use thread scoping
to assign webman loggers to related objs.

cannot complete logging configuration at "compile time" as there are many things unknown
like what functions actually become custom routines installed as async objects? way more
involved than that.
so actual approach is an acknowledgement of logger placement and 2-phase creation.
placement is about fact that loggers should be per-thread and threads are created
by custom_routine and object_and_thread calls. there can be multiple instances of
the same calls, i.e. multiple instances of both the same routines and objects.
so 2-phase is about creating logger factories in each class for routines and objects and
then calling those factories at creation time to cause the creation of loggers with
names like;

	webman.controller.api.ApiV2[f870025]
	webman.managerclient.asterisk_writer[f870025]

where there is a suffix for the thread instance. some factories will be null due to configuration
of blacklist/whitelist. pure objects just use their current_queue value to log but even that is
dependent on info compiled into their own class during startup.

obviously pure objects on a queue that is not logging will also not be able to log. this
give an extra level of control.

the base level Channel is never given a log, so sync_objects and object pools that want logging
must derive their own Channels and then ensure proper configuration to ensure that logging occurs.
the background thread does the same thing and by default logs everything.
