POSSIBLE DIRECTIONS FOR PBX MAINTENANCE TASKS

INTRODUCTION
After a phase of information gathering and discussion, the areas
covered include; the current technical scenario, related pbx/webman
software and possible directions and difficulties.

The goals of the #2444 task are inferred from statements in the
task definition;

	"prevent peak loads causing outages for big customers"

The undesirable "peak loads" are being caused by unmanaged execution
of maintenance tasks (e.g. db vacuuming and log rotation).

The underlying need for a "software update" mechanism has also been
rolled into the requirements/discussion for #2444. This is taken as
a "wish-list" item that may be bumped if it proves to be an
inconvenient extra.

EXECUTIVE SUMMARY
There are two possible implementations. The first targets a minimal
management of resource loading associated with periodic maintenance
tasks. This implementation is constrained to what is achievable in
the absence of quality communication with a centralized service. This
direction would not deliver software auto-update functionality.

The second implementation also targets the management of resource
loading, but more effectively and delivered on top of an auto-update
framework.

The first implementation has a relatively short development time and
delivers an observable "fix". It also inherits many legacy software
deficiencies and site constraints/limitations. The "fix" would
manifest in the group of customer sites that are better configured,
administered and provisioned - the good sites will get gooder.
Those sites with old software problems or difficult network
environments would not be improved. To be fair a majority of
supported sites fall into the "good" category. All software update
activity would of course remain 100% manual.

The second implementation has a longer development time - call it
"medium". It delivers proper load management, broader deployment
across the supported sites and reduction of the effort and risk
associated with site maintenance. The bulk of the benefits will
come from deliberate targeting of the network technologies used to
communicate between supported sites and a centralized service
(i.e. currently the vpn manager is the only example of such
communication). The time consumed by the software release process
courtesy of automated software updates, would be severely reduced.
The related stress of repeating all manual tasks correctly would
also be reduced.

In short, some real benefits could be realized in the short term
through the first implementation. By not addressing the difficulties
associated with different sites and network scenarios it also adds
to the complexity (i.e. headache) from a support point-of-view. Its
another patch that leaves all the other patches (or worse) right
where they are.

The second implementation is medium term but delivers more
effective load management. More importantly it delivers a significant
improvement in the product infra-structure, reaping benefits such
as reliability, broader site adoption and being truly extensible.
It also replaces an increasingly unfortunate collection of patches
and untouched corners with a single professional grade patch - hell,
it might be more accurate to say a bionic prosthesis. Delivery of
new or modified features to our users is faster and more reliable.
Developers and support staff are freed from repetitive and risky
manual work.





 

THE FULL PICTURE
The scope of this task is defined by all those instances of vadacom pbx's
that are supported by this organization. This includes a slightly
uncomfortable variety of considerations - hardware and software.

* there are clusters of pbx's in hosted environments
* there are customer-premise installations of the pbx on atoms
* there are different versions of system software such as python
* there are different versions of webman
* there are different versions of license client

Even worse these pbx's are located in a challenging array of
network configurations, relevant when 1) trying to distribute load
across the relevant LAN, 2) because of the different inbound/outbound
connectivity rules imposed at different sites and 3) because
of the unreliable presence of a functional DNS.

Our use of OpenVPN has shown itself to be a difficult choice
with a high degree of skills and attention required to keep it
running.

For a small number of sites (<6) it has been simpler to support
them manually either using basic tools such as ssh or through
site visits.

In a different area of concern, there are a variety of values
used to identify sites;

* reseller code.... a code assigned to a reseller, used by anyone
				    logging into the VPN Manager UI for that reseller
* customer code.... a code assigned to a customer (not used
				    anywhere except internal to the VPN Manager
					and is not exposed)
* system code...... a code assigned to a system, used to identify
				    a system with regards to Buddy Mobile clients,
					and the license client
* system_uuid...... a UUID created and stored in a system, used
				    to identify a system uniquely
* hardware_uuid.... a UUID extracted from the system hardware where
					possible (e.g. BIOS) or generated and stored (for
					OpenVZ and certain Atom's)

The composite key of system_uuid, hardware_uuid, systemcode is used to
uniquely identify an installation.

Codes are assigned by the VPN manager from a pool of ranges. The
final code is the result of some further machinations. There are
pending issues with the current code management strategy.

System identifiers are relevant as they can be leveraged in the
distribution of resource loading. A unique value can be reduced
arithmetically (i.e. modulo) to assign a system a "time slot".
There are a fixed number of slots available and each slot will
be shared by multiple systems. The load distribution software
will ensure that the number of systems in each slot is close to
the same.
 
Systems performing maintenance tasks during their own slot
ensure a more even load over time.

It may be the case that none of the available identifiers, or
combination of identifiers is useful in the distribution of
load. In this case there will need to be yet further identifiers
created. To reduce confusion it will be sensible to refer to
these as distribution, scope or loading identifiers.

Other strategies for distributing load include live
connections to pbx hosts. The load distribution software
would notify each host with a message indicating when - and
even what - maintenance should be performed.

REQUIREMENTS
LOAD DISTRIBUTION
* Manage all supported hosts
* Arrange for even distribution of resource loading
* Resources include CPU, RAM, DISK, devices, network bandwidth
  and defined network services.
* Maintain an audit trail of maintenance activities
* Provide effective access to the audit trail
* Consider the real possibility that connectivity to
  any centralized control may be patchy or broken. 
* Provide a watchdog feature that notifies support when
  verification of maintenance has not been received.
* Define the resolution process for out-of-maintenance hosts.

AUTOMATED SOFTWARE UPDATE
* Goal is the verified delivery of updates to all supported hosts
* Updates may include software and files
  media, db scripts, configuration, documentation
* Assume responsibility for update of all future and current
  software products or components of products.
* Maintain a host-based, audit trail of update activities
* Provide effective access to the audit trail
* Provide a watchdog feature that notifies support when
  verification of update has not been received.
* Define the resolution process for out-of-sync hosts.

* DOCUMENT ALL THE SUPPORTED INSTANCES



