# Author: Scott Woods <scott.suzuki@gmail.com>
# MIT License
#
# Copyright (c) 2017-2022
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""Support for the concept of a standard application.

Classes and functions that implement the notion of "process as an async object".
This is a 2-part task in that processes must be written in a certain way and parent
processes must "call" them in a certain way. Resulting processes can operate within
a complex hierarchy of objects, but the tools can also be used to add sophistication
to just about any application development, e.g. built-in handling of control-c,
application persistence, built-in handling of complex arguments, etc.
"""
__docformat__ = 'restructuredtext'

__all__ = [
	'ComponentFailed',
	'hb',
	'object_settings',
	'tool_settings',
	'LOG_NUMBER',
	'component_settings',
	'create_object',
	'create_tool',
	'create_component',
]

import os
import sys
import signal
import io
import time
import ansar.encode as ar
from .root import rt, start_up, tear_down
from .coding import Gas, breakpath
from .space import set_queue, get_queue_address, Completion
from .point import pt
from .lifecycle import Ready, Completed, Stop, Aborted, Faulted, Ack
from .bind import bind_any
from .log import LogAgent, log_to_stderr, log_to_nowhere, select_logs
from .rolling import RollingLog
from .home import Homebase, file_decoration, FULL_SERVICE, TOOL_SERVICE
from .locking import lock_and_hold
from .retry import RetryIntervals, Retry
from .args import command_args, sub_args, extract_args, arg_values, component_args

#
#
LOG_NUMBER = ar.Enumeration(FAULT=ar.USER_LOG_FAULT, WARNING=ar.USER_LOG_WARNING,
    CONSOLE=ar.USER_LOG_CONSOLE, OBJECT=ar.USER_LOG_OBJECT,
    TRACE=ar.USER_LOG_TRACE, DEBUG=ar.USER_LOG_DEBUG, NONE=ar.USER_LOG_NONE)

#
#
class ComponentFailed(Exception):
	def __init__(self, condition, explanation):
		Exception.__init__(self)
		self.condition = condition
		self.explanation = explanation

	def __str__(self):
		if self.explanation is None:
			s = '%s' % (self.condition,)
		else:
			s = '%s (%s)' % (self.condition, self.explanation)
		return s

#
#
A0 = breakpath(sys.argv[0])[1]

def print_out(f, **kw):
	if kw:
		f = f.format(**kw)
	sys.stderr.write(f)

def silent_exit(code=0):
	sys.exit(code)

def error_exit(e, code=None, **kw):
	if kw:
		e = e.format(**kw)
	sys.stderr.write('{a0}: '.format(a0=A0))
	sys.stderr.write(e)
	sys.stderr.write('\n')
	if code is None:
		return
	sys.exit(code)

def file_decoding(name, t):
	f = ar.File(name, t, decorate_names=False)
	d = f.recover()
	return d

def input_decoding(t):
	utf8 = io.TextIOWrapper(sys.stdin.buffer, encoding='utf-8', errors='strict')
	input = utf8.read()

	codec = ar.CodecJson()
	d = codec.decode(input, t)
	return d

def file_encoding(name, value, t):
	f = ar.File(name, t, decorate_names=False)
	f.store(value)

def settings_recover(f, compiled):
	try:
		settings, v = f.recover()
		return settings, v
	except ar.FileNotFound:
		pass
	
	try:
		f.store(compiled)
	except ar.FileFailure:
		return None, None
	return compiled, None

def output_encoding(output, e):
	encoding = ar.CodecJson(pretty_format=True)
	e = encoding.encode(output, e)
	sys.stdout.write(e)
	sys.stdout.write('\n')

def output_exit(output, code=None):
	output_encoding(output, ar.Any())
	if code is None:
		return
	sys.exit(code)

# Generate some help for command-line users,
# extracted from the settings class.
STANDARD_SYNOPSIS = '''
    $ %s [--<name>=<value> ...] \\
		[-<character>=<value> ...] \\
		[word ...]

There are zero or more settings passed to the command, and zero or
more words (e.g. file names). The <name> in the long-form setting is
matched to a member in the command settings and the <value> is assumed
to be a JSON encoding appropriate to that member. Refer to the SETTINGS
section for details on each member.

The short-form option uses a <character> to match an initial character
of a member in the command settings. Any ambiguity arising from multiple
matches results in a diagnostic and exit. Adopting the long-form avoids
this issue. The <value> is processed in the same manner for both long-
and short-form settings.

If the command expects an input object this is passed as one or
more words (e.g. file names) or on stdin. Reading of stdin is triggered
by the lack of any words.
'''

STANDARD_SAMPLE = '''A full encoding of the settings is presented below. This includes examples
of the JSON encodings that can be used as the <value> when passing a
setting on the command-line.

Presenting correct JSON encodings on a command line can become difficult
where complex data types are involved, and JSON syntax overlaps with
command-line syntax. For this reason quotes around encodings for types
such as Python str are automatically provided, e.g. --who=John will
set the "who" member to the str value "John". This automation does not
apply to a str that appears as part of a more complex encoding. Multi-line
encodings for values such as lists and sets can generally be collapsed
into a single-line. Consult a JSON reference for full details on the
handling of whitespace.
'''

# A console request for info about a component.
def settings_help(s):
	def not_available(reason):
		error_exit('no help available ({reason})', reason=reason, code=1)

	# Extract some reasonable documentation.
	if s is None:
		not_available('no defined settings')
	tos = type(s)

	not_documented = 'settings not documented'
	try:
		settings_doc = tos.__doc__
		init_doc = tos.__init__.__doc__
	except AttributeError:
		not_available(not_documented)

	if not settings_doc or not init_doc:
		not_available(not_documented)

	# Clean up the source comments.
	synopsis = settings_doc.split('\n')
	synopsis = [s.strip() for s in synopsis]
	if len(synopsis) > 2 and synopsis[0] and not synopsis[1]:
		tagline = synopsis[0]
		description = synopsis[2:]
	else:
		tagline = None
		description = synopsis
	while description and not description[-1]:
		description.pop()

	arguments = init_doc.split('\n')
	arguments = [a.strip() for a in arguments]

	arg = {}
	notes = []
	for a in arguments:
		if a.startswith('* '):
			notes = []
			arg[a[2:]] = notes
			continue
		if a:
			notes.append(a)

	# Presentation
	print_out('NAME\n')
	if tagline:
		print_out('{name} - {tagline}\n', name=A0, tagline=tagline)
	else:
		print_out('{name}\n', name=A0)
	print_out('\n')
	print_out('SYNOPSIS\n')
	print_out(STANDARD_SYNOPSIS % (A0,))
	print_out('\n')
	print_out('DESCRIPTION\n')
	for d in description:
		print_out('{line}\n', line=d)
	print_out('\n')
	print_out('SETTINGS\n')
	schema = tos.__art__.value
	for k, v in schema.items():
		print_out('--{member}=<{proto}>\n', member=k, character=k[0], proto=ar.type_to_text(v))
		try:
			notes = arg[k]
		except KeyError:
			continue
		for n in notes:
			print_out(n)
			print_out('\n')
		print_out('\n')
	print_out('SAMPLE\n')
	print_out(STANDARD_SAMPLE)
	eos = ar.UserDefined(tos)
	fake = ar.fake(eos)
	
	encoding = ar.CodecJson(pretty_format=True)
	sample = encoding.encode(fake, eos)
	print_out('\n')
	print_out(sample)
	print_out('\n')

# A console request for a copy of the current configuration.
# Generate the JSON encoding and place on stdout.
def dump_settings(settings):
	output_encoding(settings, ar.UserDefined(type(settings)))

# Custom exception deliberately using BaseException to avoid
# inadvertent catching.
#class ControlC(BaseException):
#    pass
#
#class Usr1(BaseException):
#    pass
signal_received = None

# Translate platform events into Python exceptions
# to be caught in base function.
#def catch_control_c(number, frame):
#    raise ControlC()
#
#def catch_usr_1(number, frame):
#    raise Usr1()
#
#def ignore_control_c(number, frame):
#	pass
def catch_signal(number, frame):
	global signal_received
	signal_received = number

def ignore_signal(number, frame):
	pass

# Default handling of mismatch between loaded settings and
# what the application expects.
def no_upgrade(s, v):
	c = 'version "%s" of settings' % (v,)
	raise ComponentFailed(c, 'not supported')

#
#
class ObjectSettings(object):
	def __init__(self, help=False,
			dump_settings=False, dump_input=False,
			debug_level=None,
			settings_file=None, input_file=None, output_file=None):
		self.help = help
		self.dump_settings = dump_settings
		self.dump_input = dump_input
		self.debug_level = debug_level
		self.settings_file = settings_file
		self.input_file = input_file
		self.output_file = output_file

OBJECT_SETTINGS_SCHEMA = {
	'help': ar.Boolean(),
	'dump_settings': ar.Boolean(),
	'dump_input': ar.Boolean(),
	'debug_level': LOG_NUMBER,
	'settings_file': ar.Unicode(),
	'input_file': ar.Unicode(),
	'output_file': ar.Unicode(),
}

ar.bind(ObjectSettings, object_schema=OBJECT_SETTINGS_SCHEMA)

#
#
object_settings = ObjectSettings()

def object_vector(self, object_type, settings, input, word):
	name_counts = ['"%s" (%d)' % (k, len(v)) for k, v in pt.thread_classes.items()]

	executable = os.path.abspath(sys.argv[0])
	self.trace('Executable "%s" as process (%d)' % (executable, os.getpid()))
	self.trace('Working folder "%s"' % (os.getcwd()))
	self.trace('Running object "%s"' % (object_type.__art__.path,))
	self.trace('Class threads (%d) %s' % (len(pt.thread_classes), ','.join(name_counts)))

	def create():
		if input is not None:
			return self.create(object_type, settings, input, word)
		if settings is not None:
			return self.create(object_type, settings, word)
		return self.create(object_type, word)

	a = create()
	m = self.select(Completed, Stop)

	if isinstance(m, Completed):
		# Do a "fake" signaling. Sidestep all the platform machinery
		# and just set a global. It does avoid any complexities
		# arising from overlapping events. Spent far too much time
		# trying to untangle signals, exceptions and interrupted i/o.
		global signal_received
		signal_received = signal.SIGUSR1
		return m.value

	# Received a Stop.
	self.send(m, a)
	m = self.select(Completed)
	return Aborted()

bind_any(object_vector, lifecycle=True, message_trail=True, execution_trace=True)

#
#
def standard_passing(generic_settings, special_settings):
	if special_settings is not None:
		a = generic_settings.__art__.value.keys()
		b = special_settings.__art__.value.keys()
		c = set(a) & set(b)
		if len(c) > 0:
			j = ', '.join(c)
			raise ValueError('collision in settings names - {collisions}'.format(collisions=j))
	executable, word, ls = command_args()
	x, r = extract_args(generic_settings, ls, special_settings)
	arg_values(generic_settings, x)
	return executable, word, r

# The first base function to run in the main Python thread and to interact with the
# signal machinery, to preserve the async model across process boundaries.
def create_object(object_type, settings=None, input_type=None, logs=None, parameter_passing=standard_passing):
	'''Process entry-point (#1 of 3). Command-line args, piped input, object on stdout.'''
	global signal_received

	try:
		# Parse out args vs words, split into framework settings
		# vs object.
		executable, word, r = parameter_passing(object_settings, settings)
	except ValueError as e:
		s = str(e)
		error_exit('cannot process command-line, {error}', error=s, code=1)

	# Object settings. Tunable, operational parameters.
	# Load and perform any related object_settings operations.
	if settings is not None:
		if not ar.is_message(settings):
			error_exit('cannot support settings, not a registered message', code=1)
		tos = ar.UserDefined(type(settings))
		try:
			# Allow compiled settings to be overridden by explicit
			# input file, then make assignments on top of the result.
			if object_settings.settings_file:
				settings, v = file_decoding(object_settings.settings_file, tos)
			arg_values(settings, r)
		except ar.FileFailure as e:
			s = str(e)
			error_exit('cannot recover settings from file, {error}', error=s, code=1)
		except ar.CodecFailed as e:
			s = str(e)
			error_exit('cannot recover settings from file, {error}', error=s, code=1)
		except ValueError as e:
			s = str(e)
			error_exit('cannot assign settings, {error}', error=s, code=1)
		
		# Now that settings are resolved
		if object_settings.help:
			settings_help(settings)
			silent_exit()
		elif object_settings.dump_settings:
			try:
				dump_settings(settings)
			except ar.CodecFailed as e:
				s = str(e)
				error_exit('cannot dump settings, {error}', error=s, code=1)
			silent_exit()
		
		if object_settings.debug_level is not None:
			logs = logs or select_logs(object_settings.debug_level)
		else:
			logs = logs or log_to_nowhere
	elif object_settings.help:
		error_exit('cannot provide help, no settings defined', code=1)
	elif object_settings.dump_settings:
		error_exit('cannot dump settings, no settings defined', code=1)
	elif object_settings.settings_file:
		error_exit('cannot recover settings, no settings defined', code=1)
	else:
		logs = logs or log_to_nowhere

	# Primary input. Object expects to work on an instance of
	# input_type. Load from file or pipe.
	input = None
	if input_type is not None:
		if not ar.is_message_class(input_type):
			error_exit('cannot support input type, not a registered message', code=1)
		toi = ar.UserDefined(input_type)
		if object_settings.dump_input:
			fake = ar.fake(toi)
			output_encoding(fake, toi)
			silent_exit()
		try:
			if object_settings.input_file:
				input, v = file_decoding(object_settings.input_file, toi)
			elif not word:
				input, v = input_decoding(toi)
		except ar.FileFailure as e:
			s = str(e)
			error_exit('cannot decode file input, {error}', error=s, code=1)
		except ar.CodecFailed as e:
			s = str(e)
			error_exit('cannot decode input, {error}', error=s, code=1)
	elif object_settings.input_file:
		error_exit('cannot recover input file, no input defined', code=1)
	elif object_settings.dump_input:
		error_exit('cannot dump input, no input defined', code=1)

	error_condition = None
	exit_code = 0
	output_value = None
	try:
		# Translation between SIGINT and the Stop message.
		signal.signal(signal.SIGTERM, ignore_signal)
		signal.signal(signal.SIGINT, catch_signal)

		# Start up async world.
		root = start_up(logs)

		# Create the async object.
		a = root.create(object_vector, object_type, settings, input, word)

		# Termination of this function is
		# either by SIGINT (control-c) or assignment by object_vector.
		while signal_received is None:
			time.sleep(0.1)

		# If it was keyboard then async object needs
		# to be bumped.
		if signal_received != signal.SIGUSR1:
			root.send(Stop(), a)
		m = root.select(Completed)
		value = m.value

		# Translate async completion to a standard exit code or
		# error diagnostic and code.
		if isinstance(value, int):			# Normal termination.
			exit_code = value
		elif isinstance(value, Aborted):
			# Aborted is the final step in the termination
			# protocol. It is normal for processes to terminate.
			exit_code = 0
		elif isinstance(value, Faulted):	# Convert object problems to console diagnostic.
			error_condition = str(value)
			exit_code = 1
		elif ar.is_message(value):
			output_value = value
		else:
			error_condition = 'unexpected object completion %r' % (value,)
			exit_code = 1
	except KeyboardInterrupt:
		error_condition = 'unexpected keyboard interrupt'
		exit_code = 1
	except SystemExit:
		error_condition = 'unexpected system exit'
		exit_code = 1
	except Exception as e:
		s = str(e)
		error_condition = 'unhandled exception (%s)' % (s,)
		exit_code = 1
	except:
		error_condition = 'unhandled opaque exception'
		exit_code = 1
	finally:
		if error_condition is not None:
			error_exit(error_condition)
		elif output_value is not None:
			try:
				if object_settings.output_file:
					file_encoding(object_settings.output_file, output_value, ar.Any())
				else:
					output_encoding(output_value, ar.Any())
			except ar.FileFailure as e:
				s = str(e)
				error_exit('cannot encode file output, {error}', error=s)
				exit_code = 1
			except ar.CodecFailed as e:
				s = str(e)
				error_exit('cannot encode output, {error}', error=s)
				exit_code = 1
			except Exception as e:
				s = str(e)
				error_exit('unexpected exception during output, {error}', error=s)
				exit_code = 1
				
		tear_down(code=exit_code)

#
#
class ToolSettings(object):
	def __init__(self, help=False,
			dump_settings=False, load_settings=False,
			dump_input=False,
			debug_level=None,
			settings_file=None, input_file=None, output_file=None,):
		self.help = help
		self.dump_settings = dump_settings
		self.load_settings = load_settings
		self.dump_input = dump_input
		self.debug_level = debug_level
		self.settings_file = settings_file
		self.input_file = input_file
		self.output_file = output_file

TOOL_SETTINGS_SCHEMA = {
	'help': ar.Boolean(),
	'dump_settings': ar.Boolean(),
	'load_settings': ar.Unicode(),
	'dump_input': ar.Boolean(),
	'debug_level': LOG_NUMBER,
	'settings_file': ar.Unicode(),
	'input_file': ar.Unicode(),
	'output_file': ar.Unicode(),
}

ar.bind(ToolSettings, object_schema=TOOL_SETTINGS_SCHEMA)

#
#
tool_settings = ToolSettings()

def tool_vector(self, object_type, settings, input, word):
	name_counts = ['"%s" (%d)' % (k, len(v)) for k, v in pt.thread_classes.items()]

	executable = os.path.abspath(sys.argv[0])
	self.trace('Executable "%s" as process (%d)' % (executable, os.getpid()))
	self.trace('Working folder "%s"' % (os.getcwd()))
	self.trace('Running object "%s"' % (object_type.__art__.path,))
	self.trace('Class threads (%d) %s' % (len(pt.thread_classes), ','.join(name_counts)))

	def create():
		if input is not None:
			return self.create(object_type, settings, input, word)
		if settings is not None:
			return self.create(object_type, settings, word)
		return self.create(object_type, word)

	a = create()
	m = self.select(Completed, Stop)

	if isinstance(m, Completed):
		# Do a "fake" signaling. Sidestep all the platform machinery
		# and just set a global. It does avoid any complexities
		# arising from overlapping events. Spent far too much time
		# trying to untangle signals, exceptions and interrupted i/o.
		global signal_received
		signal_received = signal.SIGUSR1
		return m.value

	# Received a Stop.
	self.send(m, a)
	m = self.select(Completed)
	return Aborted()

bind_any(tool_vector, lifecycle=True, message_trail=True, execution_trace=True)

# The global home for this instance of
# the framework.
hb = Homebase()

# The second process start-up function.
def create_tool(object_type, settings=None, input_type=None, logs=None, parameter_passing=standard_passing):
	'''Process entry-point (#2 of 3). Adds persisted settings in user's $HOME.'''
	global signal_received

	try:
		# Parse out args vs words, split into framework settings
		# vs object.
		executable, word, r = parameter_passing(tool_settings, settings)

	except ValueError as e:
		s = str(e)
		error_exit('cannot process command-line, {error}', error=s, code=1)

	try:
		# Where are the all the tool settings?
		base = os.getenv('ANSAR_TOOL') or os.getenv('HOME') or os.getcwd()
		path = os.path.join(base, '.ansar-tool')

		# Fixed, shared role.
		bp = breakpath(executable)
		role = bp[1]

		# Use stripped down set of services - no logs, etc.
		hb.home_role(path, role=role, plan=TOOL_SERVICE, executable=executable, settings=settings)
	except (ValueError, RuntimeError, OSError) as e:
		s = str(e)
		error_exit('cannot establish runtime, {error}', error=s, code=1)

	# Tool settings. Tunable, operational parameters and persisted.
	# Load and perform any related tool_settings operations.
	if settings is not None:
		if not ar.is_message(settings):
			error_exit('cannot support settings, not a registered message', code=1)
		tos = ar.UserDefined(type(settings))
		# A new collection of settings are being presented for
		# persistent use.
		if tool_settings.load_settings:
			try:
				f = ar.File(tool_settings.load_settings, tos, decorate_names=False)
				s, v = f.recover()
				hb.role_settings[1].store(s)
			except (ar.FileFailure, ar.CodecFailed) as e:
				s = str(e)
				error_exit('cannot load settings, {error}', error=s, code=1)
			silent_exit()

		try:
			# Allow persisted settings to be overridden by explicit
			# input file, then make assignments on top of the result.
			if tool_settings.settings_file:
				settings, v = file_decoding(tool_settings.settings_file, tos)
			else:
				settings, v = settings_recover(hb.role_settings[1], settings)
			arg_values(settings, r)
		except ValueError as e:
			s = str(e)
			error_exit('cannot assign settings, {error}', error=s, code=1)
		except (ar.FileFailure, ar.CodecFailed) as e:
			s = str(e)
			error_exit('cannot recover settings from file, {error}', error=s, code=1)
		
		# Settings are resolved. Carry out any user-requested
		# actions.
		if tool_settings.help:
			settings_help(settings)
			silent_exit()
		elif tool_settings.dump_settings:
			try:
				dump_settings(settings)
			except ar.CodecFailed as e:
				s = str(e)
				error_exit('cannot dump settings, {error}', error=s, code=1)
			silent_exit()

		if tool_settings.debug_level is not None:
			logs = logs or select_logs(tool_settings.debug_level)
		else:
			logs = logs or log_to_nowhere
	elif tool_settings.help:
		error_exit('cannot provide help, no settings defined', code=1)
	elif tool_settings.dump_settings:
		error_exit('cannot dump settings, no settings defined', code=1)
	elif tool_settings.load_settings:
		error_exit('cannot load settings, no settings defined', code=1)
	elif tool_settings.settings_file:
		error_exit('cannot recover file settings, no settings defined', code=1)
	else:
		logs = logs or log_to_nowhere

	# Primary input. Object expects to work on an instance of
	# input_type. Load from file or pipe.
	input = None
	if input_type is not None:
		if not ar.is_message_class(input_type):
			error_exit('cannot support input type, not a registered message', code=1)
		toi = ar.UserDefined(input_type)
		if tool_settings.dump_input:
			fake = ar.fake(toi)
			output_encoding(fake, toi)
			silent_exit()
		try:
			if tool_settings.input_file:
				input, v = file_decoding(tool_settings.input_file, toi)
			elif not word:
				input, v = input_decoding(toi)
		except ar.FileFailure as e:
			s = str(e)
			error_exit('cannot decode file input, {error}', error=s, code=1)
		except ar.CodecFailed as e:
			s = str(e)
			error_exit('cannot decode input, {error}', error=s, code=1)
	elif tool_settings.input_file:
		error_exit('cannot recover input file, no input defined', code=1)
	elif tool_settings.dump_input:
		error_exit('cannot dump input, no input defined', code=1)

	error_condition = None
	exit_code = 0
	output_value = None
	try:
		# Translation between SIGINT and the Stop message.
		signal.signal(signal.SIGINT, catch_signal)
		signal.signal(signal.SIGTERM, ignore_signal)

		# Start up async world.
		root = start_up(logs)

		# Create the async object.
		a = root.create(object_vector, object_type, settings, input, word)

		# Termination of this function is
		# either by SIGINT (control-c) or assignment by object_vector.
		while signal_received is None:
			time.sleep(0.1)

		# If it was keyboard then async object needs
		# to be bumped.
		if signal_received != signal.SIGUSR1:
			root.send(Stop(), a)
		m = root.select(Completed)
		value = m.value

		# Translate async completion to a standard exit code or
		# error diagnostic and code.
		if isinstance(value, int):			# Normal termination.
			exit_code = value
		elif isinstance(value, Aborted):
			exit_code = 128 + signal.SIGINT
		elif isinstance(value, Faulted):	# Convert object problems to console diagnostic.
			error_condition = str(value)
			exit_code = 1
		elif ar.is_message(value):
			output_value = value
		else:
			error_condition = 'unexpected object completion %r' % (value,)
			exit_code = 1
	except KeyboardInterrupt:
		error_condition = 'unexpected keyboard interrupt'
		exit_code = 1
	except SystemExit:
		error_condition = 'unexpected system exit'
		exit_code = 1
	except Exception as e:
		s = str(e)
		error_condition = 'unhandled exception (%s)' % (s,)
		exit_code = 1
	except:
		error_condition = 'unhandled opaque exception'
		exit_code = 1
	finally:
		if error_condition is not None:
			error_exit(error_condition)
		elif output_value is not None:
			try:
				if tool_settings.output_file:
					file_encoding(tool_settings.output_file, output_value, ar.Any())
				else:
					output_encoding(output_value, ar.Any())
			except (ar.FileFailure, ar.CodecFailed) as e:
				s = str(e)
				error_exit('cannot encode file output, {error}', error=s)
				exit_code = 1
			except Exception as e:
				s = str(e)
				error_exit('unexpected exception during output, {error}', error=s)
				exit_code = 1
				
		tear_down(code=exit_code)

#
#
class ComponentSettings(object):
	def __init__(self, help=False,
			dump_settings=False,
			dump_input=False,
			store_settings=False,
			debug_level=None,
			settings_file=None, input_file=None, output_file=None,
			home_path=None, role_name=None,
			redirect_bin=None,
			redirect_settings=None,
			redirect_logs=None,
			redirect_resource=None,
			redirect_tmp=None,
			redirect_model=None,
			retry_intervals=None,
			call_signature=None,
			point_of_origin=2):		# Default is ORIGIN_CALL. Needs import but currently creates conflicts.
		self.help = help
		self.dump_settings = dump_settings
		self.dump_input = dump_input
		self.store_settings = store_settings
		self.debug_level = debug_level
		self.settings_file = settings_file
		self.input_file = input_file
		self.output_file = output_file
		self.home_path = home_path
		self.role_name = role_name
		self.redirect_bin = redirect_bin
		self.redirect_settings = redirect_settings
		self.redirect_logs = redirect_logs
		self.redirect_resource = redirect_resource
		self.redirect_tmp = redirect_tmp
		self.redirect_model = redirect_model
		self.retry_intervals = retry_intervals
		self.call_signature = call_signature
		self.point_of_origin = point_of_origin

COMPONENT_SETTINGS_SCHEMA = {
	'help': ar.Boolean(),
	'dump_settings': ar.Boolean(),
	'dump_input': ar.Boolean(),
	'store_settings': ar.Boolean(),
	'debug_level': LOG_NUMBER,
	'settings_file': ar.Unicode(),
	'input_file': ar.Unicode(),
	'output_file': ar.Unicode(),
	'home_path': ar.Unicode(),
	'role_name': ar.Unicode(),
	'redirect_bin': ar.Unicode(),
	'redirect_settings': ar.Unicode(),
	'redirect_logs': ar.Unicode(),
	'redirect_resource': ar.Unicode(),
	'redirect_tmp': ar.Unicode(),
	'redirect_model': ar.Unicode(),
	"retry_intervals": ar.UserDefined(RetryIntervals),
	'call_signature': ar.Unicode(),
	'point_of_origin': ar.Integer8(),
}

ar.bind(ComponentSettings, object_schema=COMPONENT_SETTINGS_SCHEMA)

# A set of values that pass across the process boundary
# as command-line args and used by the framework.
component_settings = ComponentSettings()

#
#
def component_vector(self, object_type, settings, input, word):
	name_counts = ['"%s" (%d)' % (k, len(v)) for k, v in pt.thread_classes.items()]

	executable = os.path.abspath(sys.argv[0])
	self.trace('Executable "%s" as process (%d)' % (executable, os.getpid()))
	self.trace('Working folder "%s"' % (os.getcwd()))
	self.trace('Running object "%s"' % (object_type.__art__.path,))
	self.trace('Class threads (%d) %s' % (len(pt.thread_classes), ','.join(name_counts)))

	def create():
		if input is not None:
			return self.create(object_type, settings, input, word)
		if settings is not None:
			return self.create(object_type, settings, word)
		return self.create(object_type, word)

	if hb.role_retry and hb.role_retry[2]:
		def attempt(self, work):
			a = create()
			return a
		a = self.create(Retry, attempt, hb.role_retry[2])
	else:
		a = create()
	m = self.select(Completed, Stop)

	if isinstance(m, Completed):
		# Do a "fake" signaling. Sidestep all the platform machinery
		# and just set a global. It does avoid any complexities
		# arising from overlapping events. Spent far too much time
		# trying to untangle signals, exceptions and interrupted i/o.
		global signal_received
		signal_received = signal.SIGUSR1
		return m.value

	# Received a Stop.
	self.send(m, a)
	m = self.select(Completed)
	return Aborted()

bind_any(component_vector, lifecycle=True, message_trail=True, execution_trace=True)

def call_signature(c):
	if component_settings.call_signature is None:
		return False
	return c in component_settings.call_signature

# The third process start-up function.
def create_component(object_type, settings=None, input_type=None):
	'''Process entry-point (#3 of 3). Adds process management and full runtime environment.'''
	global signal_received

	try:
		# Parse out args vs words, split into framework settings
		# vs object.
		executable, word, ls = command_args()
		x, r = extract_args(component_settings, ls, None)
		arg_values(component_settings, x)
	except ValueError as e:
		f = Faulted('cannot process command-line', str(e))
		output_exit(f, code=0)

	try:
		# Where are the managed processes?
		path = component_settings.home_path or '.ansar-home'
		path = os.path.abspath(path)

		# Which one am I?
		bp = breakpath(executable)
		default_role = '{name}-0'.format(name=bp[1])
		role = component_settings.role_name or default_role

		redirect = {}
		if component_settings.redirect_bin: redirect['bin'] = component_settings.redirect_bin
		if component_settings.redirect_settings: redirect['settings'] = component_settings.redirect_settings
		if component_settings.redirect_logs: redirect['logs'] = component_settings.redirect_logs
		if component_settings.redirect_resource: redirect['resource'] = component_settings.redirect_resource
		if component_settings.redirect_tmp: redirect['tmp'] = component_settings.redirect_tmp
		if component_settings.redirect_model: redirect['model'] = component_settings.redirect_model

		default_bin = bp[0]
		retry = component_settings.retry_intervals

		hb.home_role(path, role=role, executable=bp[1],
			settings=settings, redirect=redirect,
			default_bin=default_bin, retry=retry)
		if hb.role_executable and hb.role_executable[2] != bp[1]:
			raise RuntimeError('running executable does not match the <executable> defined in the role')
	except (ValueError, RuntimeError, OSError) as e:
		f = Faulted('cannot establish runtime', str(e))
		output_exit(f, code=0)

	# Component settings. Tunable, operational parameters and persisted.
	# Load and perform any related component_settings operations.
	if settings is not None:
		if not ar.is_message(settings):
			f = Faulted('cannot support settings', 'not a registered message')
			output_exit(f, code=0)
		tos = ar.UserDefined(type(settings))
		try:
			# Allow persisted settings to be overridden by explicit
			# input file, then make assignments on top of the result.
			if component_settings.settings_file:
				settings, v = file_decoding(component_settings.settings_file, tos)
			else:
				settings, v = settings_recover(hb.role_settings[1], settings)
			arg_values(settings, r)
		except ValueError as e:
			f = Faulted('cannot assign settings', str(e))
			output_exit(f, code=0)
		except (ar.FileFailure, ar.CodecFailed) as e:
			f = Faulted('cannot recover settings from file', str(e))
			output_exit(f, code=0)
		
		# Settings are resolved. Carry out any user-requested
		# actions. Assume this is at the console.
		if component_settings.help:
			settings_help(settings)
			silent_exit()
		elif component_settings.dump_settings:
			try:
				dump_settings(settings)
			except ar.CodecFailed as e:
				s = str(e)
				error_exit('cannot dump settings, {error}', error=s, code=1)
			silent_exit()
		elif component_settings.store_settings:
			try:
				hb.role_settings[1].store(settings)
			except (ar.FileFailure, ar.CodecFailed) as e:
				f = Faulted('cannot store settings', str(e))
				output_exit(f, code=0)
			output_exit(Ack(), code=0)
	elif component_settings.help:
		error_exit('cannot provide help, no settings defined', code=1)
	elif component_settings.dump_settings:
		error_exit('cannot dump settings, no settings defined', code=1)
	elif component_settings.settings_file:
		error_exit('cannot recover file settings, no settings defined', code=1)
	elif component_settings.store_settings:
		if r[0] or r[1]:
			f = Faulted('cannot store settings', 'no settings defined')
			output_exit(f, code=0)
		output_exit(Ack(), code=0)

	# Primary input. Object expects to work on an instance of
	# input_type. Load from file or pipe.
	input = None
	if input_type is not None:
		#if not ar.is_message_class(input_type):
		#	f = Faulted('cannot support input type', 'not a registered message')
		#	output_exit(f, code=0)
		#toi = ar.UserDefined(input_type)
		toi = ar.fix_expression(input_type, {})
		if component_settings.dump_input:
			fake = ar.fake(toi)
			output_encoding(fake, toi)
			silent_exit()
		try:
			# Explicit file has priority, then the presence
			# of command-line words (e.g. files), then input
			# piped from the parent.
			if component_settings.input_file:
				input, v = file_decoding(component_settings.input_file, toi)
			elif word:
				pass
			elif component_settings.call_signature is None or 'i' in component_settings.call_signature:
				input, v = input_decoding(toi)
			else:
				f = Faulted('call signature mismatch', 'expected input not piped by parent')
				output_exit(f, code=0)
		except (ar.FileFailure, ar.CodecFailed) as e:
			f = Faulted('cannot decode input', str(e))
			output_exit(f, code=0)
	elif component_settings.input_file:
		f = Faulted('cannot recover input file', 'no input defined')
		output_exit(f, code=0)
	elif component_settings.dump_input:
		f = Faulted('cannot dump input', 'no input defined')
		output_exit(f, code=0)
	elif call_signature('i'):
		f = Faulted('call signature mismatch', 'no input defined')
		output_exit(f, code=0)

	try:
		if component_settings.point_of_origin == 0:		# Start
			logs = RollingLog(hb.role_logs.path)		# Everything goes in here.
		elif component_settings.point_of_origin == 1:	# Run
			if component_settings.debug_level is None:
				component_settings.debug_level = LOG_NUMBER.DEBUG
				logs = select_logs(LOG_NUMBER.DEBUG)
			else:
				logs = select_logs(component_settings.debug_level)
		else:	# Call.
			if component_settings.debug_level is not None:
				logs = select_logs(component_settings.debug_level)
			else:
				logs = RollingLog(hb.role_logs.path)		# Everything goes in here.
	except OSError as e:
		f = Faulted('cannot initiate logging', str(e))
		output_exit(f, code=0)

	error_condition = None
	exit_code = 0
	output_value = None
	early_return = False
	root = None
	try:
		# Translation between SIGINT and the Stop message.
		signal.signal(signal.SIGINT, catch_signal)
		signal.signal(signal.SIGTERM, ignore_signal)

		# Start up async world.
		root = start_up(logs)

		if hb.role_entry:
			name = 'lockup'
			a = root.create(lock_and_hold, hb.role_entry.path, name)
			root.assign(a, name)
			m = root.select(Ready, Completed)
			if isinstance(m, Completed):	# Cannot lock.
				root.debrief()
				raise Completion(m.value)	# Jump forward for early shutdown.

		cs = component_settings.call_signature
		no_output = cs is not None and 'o' not in cs
		if component_settings.point_of_origin == 0 or no_output:
			early_return = True
			output_encoding(Ack(), ar.Any())
			sys.stdout.close()
			os.close(1)

		#
		#
		hb.entry_started()

		# Create the async object.
		a = root.create(component_vector, object_type, settings, input, word)

		# Termination of this function is
		# either by SIGINT (control-c) or assignment by object_vector.
		while signal_received is None:
			time.sleep(0.1)

		# If it was keyboard then async object needs
		# to be bumped.
		if signal_received != signal.SIGUSR1:
			root.send(Stop(), a)
		m = root.select(Completed)
		value = m.value

		# Translate async completion to a standard exit code or
		# error diagnostic and code.
		if isinstance(value, Aborted):
			output_value = value
		elif isinstance(value, Faulted):	# Convert object problems to console diagnostic.
			output_value = value
		elif ar.is_message(value):
			output_value = value
		else:
			error_condition = 'unexpected object completion %r' % (value,)
	except Completion as c:
		output_value = c.value
	except KeyboardInterrupt:
		error_condition = 'unexpected keyboard interrupt'
	except SystemExit:
		error_condition = 'unexpected system exit'
	except Exception as e:
		s = str(e)
		error_condition = 'unhandled exception (%s)' % (s,)
	except:
		error_condition = 'unhandled opaque exception'
	finally:
		# Clear the lock.
		if root is not None:
			root.abort()
			while root.working():
				root.select(Completed)
				root.debrief()

		if error_condition is not None:
			output_value = Faulted('object failure', error_condition)

		# Close the active record.
		hb.entry_returned(output_value)

		#
		#
		if output_value is not None:
			try:
				if component_settings.output_file:
					file_encoding(component_settings.output_file, output_value, ar.Any())
				elif not early_return:
					output_encoding(output_value, ar.Any())
			except (ar.FileFailure, ar.CodecFailed) as e:
				if not early_return:
					f = Faulted('cannot encode output', str(e))
					output_exit(f)
			except Exception as e:
				if not early_return:
					f = Faulted('unexpected exception during output', str(e))
					output_exit(f)
				
		tear_down(code=exit_code)

