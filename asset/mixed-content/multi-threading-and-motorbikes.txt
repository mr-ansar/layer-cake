Motorcycling And Multi-Threading - Why Do It?
Right around the time I discovered programming I was also buying my first motorbike. One of these challenged my brain and the other got my heart-rate going. There was a crude yin-yang in that pairing. Turning abstractions into tangible lines of C++ was well removed from the speed, smell and noise of biking, but in a good way. Too much of one was treated with more time on the other.
Along the way I met really good coders and really good riders, even sharing a track with a world champion. Getting a few pointers (no pun intended) from that guy was actually not fun. There is a huge distance between someone that can bask in the glory of global dominance and someone that thinks basking in the sun is a solid effort. No disrespect to Fred - stylish and friendly at all times.
Going fast on a motorbike is not for everyone. It takes time, money, skill and a risk-taking mindset. If you are prepared to spend time at the edge of your competency you can learn a lot. The downside of all that quality time is that it will eventually lead to crashes. After the adrenaline levels drop off and you are thanking your lucky stars that there are no broken bones, you are left with the embarrassing evidence of your latest hubris. Then you have to turn away and figure out the shortest route back to where you have setup for the day. Including the Walk Of Shame past other riders waiting for their turn on the track.

When the laps are going well there is the inevitable thought - how can I do this even better? That might be driven by an obsession to be world champion, or the simpler desire to feel more competent. Competence on a racetrack converts fairly well to competence on the road, and that makes you safer. 
Having decided to spend more money on "doing it better", it might come as a surprise to some, where that expenditure usually goes. The top three options would be rider training, a set of better tyres or suspension improvements. Most notably, engine improvements (i.e. increasing power) are not at the top of the list.
Brushing some distracting details aside, the interesting truth is that more power does not help the average rider to go quicker around a racetrack. It is improving control that reaps more benefits than increasing power. In fact, unless we are talking about a decently-skilled rider, a smaller capacity motorbike and a big racetrack with straights stretching for a kilometre (half a mile), an increase in power is just as likely to make things worse.
Adding multi-threading to your application is a bit like adding horsepower to your motorbike. Without proper control over the threads you create the consequences can be awful. These include;
crashes associated with illegal memory access or data corruption associated with multi-access
flakey behaviour similar to the above but different in that the application can continue for undefined periods
lockups where the application becomes completely unresponsive, perhaps to the point that it cannot be killed

A few considerations for anyone thinking that a single multi-threaded operation is going to be easy include;
how is all necessary information passed safely from the application to the thread (i.e. in most programming languages the information is best duplicated),
how is completion of the thread detected in a way that doesnt compromise the responsiveness of the application,
how are the results passed safely to the application,
how does the application cancel an active thread when the user decides its not worth the wait or the entire application is being closed, i.e. due to shutdown of the host,
will the implementation of the threaded operation support multiple instances of those operations and,
will the machinery developed for the first threaded operation be reusable for other background operations?

In between there is the typical developer that uses multi-threading when its absolutely needed, uses the related facilities carefully and keeps that part of an application as contained as possible.
crashes
flakey
corruption
lock-ups

If the price of multi-threading can be so bad its worth remembering why we bother with it
concurrency
separation of concern
technical constraints
external events
concurrency is the biggie. and that delivers
performance
better utilization of resources
service availability

I have also worked with incredibly productive software developers. There have been a few guys that I would call full-stack developers - with the skills to drive UX design and implementation through to multi-processing backends, and all of that founded on a deep knowledge of computing platforms and networks. Other than a good, general ability to turn concepts into code and a fascination with compilers and distributed computing, I always felt like someone else new specific areas better than I did.
